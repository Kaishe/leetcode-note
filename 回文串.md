解决回文串问题的核心是双指针

一个很有意义但错误的思路：既然回文串是正着反着读都一样的字符串，那么把s反转得到s‘，在s和s’中寻找最长公共子串即可

正确的思路是使用双指针：

其核心思想是从中间开始向两边扩散来判断回文串

### 最长回文子串

对于最长回文串：

```c++
for 0 <= i < len(s):
    找到以 s[i] 为中心的回文串
    更新答案
```

考虑到回文串的长度有可能是奇数也可能是偶数，进行修改：

```c++
for 0 <= i < len(s):
    找到以 s[i] 为中心的回文串
    找到以 s[i] 和 s[i+1] 为中心的回文串
    更新答案
```

为了方便完成奇数和偶数的情况写一个函数寻找以i或i+1为中心的回文串

```c++
string palindrome(string& s,int l,int r){
        while(l>=0&&r<s.size()&&s[l]==s[r]){
            l--;
            r++;
        }
        return s.substr(l+1,r-l-1);
    }
```

最后再比较大小

```c++
string longestPalindrome(string s) {
        string res;
        for(int i=0;i<s.size();i++){
            string s1=palindrome(s,i,i);
            string s2=palindrome(s,i,i+1);
            res=res.size()>s1.size()?res:s1;
            res=res.size()>s2.size()?res:s2;
        }
        return res;
    }
```

### 回文单链表

寻找回文串的核心是从中间向两端扩展

判断一个字符串是不是回文串，就不需要考虑奇偶情况，只需要双指针技巧，从两端向中间逼近即可

```c++
bool isPalindrome(string s) {
    int left = 0, right = s.length - 1;
    while (left < right) {
        if (s[left] != s[right])
            return false;
        left++; right--;
    }
    return true;
}
```

单链表的难点在于无法倒着遍历，不能使用双指针技巧。一种方法是把原始链表反转存入一条新的链表，比较两条链表是否相同

但其实，借助二叉树后序遍历的思路，不需要显式反转原始链表也可以倒序遍历链表

对于二叉树的遍历方式：

```c++
void traverse(TreeNode root) {
    // 前序遍历代码
    traverse(root.left);
    // 中序遍历代码
    traverse(root.right);
    // 后序遍历代码
}
```

而链表的前序遍历和后序遍历可以表示为：

```c++
void traverse(ListNode head) {
    // 前序遍历代码
    traverse(head.next);
    // 后序遍历代码
}
```

稍作修改，可以模仿双指针实现回文判断的功能：

```c++
// 左侧指针
ListNode left;

boolean isPalindrome(ListNode head) {
    left = head;
    return traverse(head);
}

boolean traverse(ListNode right) {
    if (right == null) return true;
    boolean res = traverse(right.next);
    // 后序遍历代码
    res = res && (right.val == left.val);
    left = left.next;
    return res;
}
```

这样做的实际上就是把链表节点放入一个栈，然后再拿出来，元素顺序就反过来了，只不过这俩利用的是递归函数的堆栈

#### 优化空间复杂度

思路是找到链表的中点，然后将链表的后半段反转，再利用双指针加以比较

通过快慢指针找到链表的中点

```c++
ListNode slow, fast;
slow = fast = head;
while (fast != null && fast.next != null) {
    slow = slow.next;
    fast = fast.next.next;
}
// slow 指针现在指向链表中点
```

如果`fast`指针没有指向`null`，说明链表长度为奇数，`slow`还要再前进一步：

```c++
if (fast != null)
    slow = slow.next;
```

从slow开始反转，开始比较回文串

```c++
ListNode left = head;
ListNode right = reverse(slow);

while (right != null) {
    if (left.val != right.val)
        return false;
    left = left.next;
    right = right.next;
}
return true;
```





### 最长回文子序列

最长回文子序列的难度在于他是不连续的序列，穷举都不容易

子序列相关问题有两种模板。一旦涉及子序列的最值，一般都是考察动态规划技巧，时间复杂度一般是O（n^2）

两种模板对应两种定义dp数组的思路

#### 1.一个一维的dp数组

